[[03. Функции#try, catch, finally]]
[[03. Функции#This]]
[[03. Функции#Замыкания]]
[[03. Функции#Promise]]


## try, catch, finally
Конструкция для отлова ошибок.

Выглядит так:
```javascript
try{
	const x = 0
	x = 10
	throw new Error('Error')
}catch(err){
	console.log(err)
}finally{
	console.log("Скрипт, который выполнится в любом случае")
}
```

Если в секции `try` будет выведена ошибка, то продолжение блока `try` завершается и происходит переход в блок `catch`. Он существует для отлова и обработки ошибки.

Блок `finally` будет выполнен не зависимо от исхода как `try`, так и `catch`.

*Если в `catch` будет выведена ошибка, то код Javascript останавливается*

Так же есть оператор `throw` который генерирует ошибку. В последствии передастся в качестве аргумента в `catch`. 


## This
В зависимости где будет вызвано ключевое слово this, результат будет разным.

Если вызвать ключевое слово в глобальной видимости или в функции, то this будет ссылаться на глобальный объект window.

Но, если вызвать this у метода объекта, то оно будет ссылаться на сам объект в котором вызван метод.

Однако, если метод будет вызывать функцию написанную с помощью стрелочной функции, то this ссылается на window.

```javascript
let obj = {
	name: "Danil",
	nameWhatch(){
		return this.name
	}
}

console.log("Это имя:", obj.nameWhatch())
// "Это имя: Danil"
```

## Замыкания
Замыкание - это комбинация функций и лексической области видимости, в которой эта функция была вызвана.

Пример:
```javascript
function nameFunction(){
	let a = 0
	return{
		()=>{
			return a++
		}
	}
}
```

В данном участке кода представлена функциональность замыкания.

По сути для того, что бы переменную не объявлять званого каждый раз или не засорять глобальную область видимости не нужными переменными, можно ей воспользоваться.

Переменная `a` остается в области видимости функции `nameFunction`, а манипуляции с ней производит безымянная функция, которая возвращается.

*Переменная остается в `scope`, так как javascript видит, что в дальнейшем, так как во вложенной функции обращаются к ней, возможно изменение значений.*

## Promise
```javascript
let promise = new Promise(function(resolve, reject){
	// функция-исполнитель (executor)
	resolve("done") /*или*/ reject(new Error("error"))
})
promise
	.then(()=>{})
	.catch(()=>{})
	.finally(()=>{})
```

Аргументы - колбэки функции:
- `resolve(value)` - eсли работа завершилась успешно,  с результатом `value`.
- `reject(error)` - если произошла ошибка, `error` - объект ошибки

Методы Promise:
- `.then((resolve)=>{})` - будет выполнена функция, если работа завершилась успешно. Так же можно передавать значение переданное в `resolve`.
- `.catch((reject)=>{})` - будет выполнена функция, если работа завершилась с ошибкой. Так же может передавать значение переданное в `reject`.
- `.finally(()=>{})`- будет выполнена функция, после сработки любого исхода.

У объекта promise, есть внутренние свойства:
- state (`"состояние"`) - вначале `"pending"`(`"ожидание"`), потом `"fulfilled"`(`"Выполненно успешно"`) при вызове ___resolve___ или `"rejected"`(`"Выполнено с ошибкой"`) при вызове ___reject___.
- result (`"результат"`) - вначале `"undefined"`, далее изменится на `"value"` при вызову ___resolve(value)___ или на `"error"` при вызову ___reject(error)___.
![[Pasted image 20241212083837.png]]

Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние Promise может быть изменено только один раз. Последующее вызов `resolve` или `reject` будет игнорирован.

## async / defer

В Javascript как в теге есть 2 атрибута для.
```html
<script defer > </script>
```
Атрибут `defer` сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.
- Скрипты с `defer` никогда не блокируют страницу.
- Скрипты с `defer` всегда выполняются, когда дерево DOM готово, но до события `DOMContentLoaded`.
- Атрибут `defer` предназначен только для внешних скриптов

Атрибут `async` означает, что скрипт абсолютно независим:

- Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.
- Событие `DOMContentLoaded` и асинхронные скрипты не ждут друг друга:
    - `DOMContentLoaded` может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),
    - …так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)
- Остальные скрипты не ждут `async`, и скрипты c`async` не ждут другие скрипты.
- Асинхронные скрипты очень полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и т.д.

 *Атрибут `defer` и `async` будет проигнорирован, если в теге `<script>` нет `src`.

|         | Порядок                                                      | `DOMContentLoaded`                                                                                                                                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `async` | _Порядок загрузки_ (кто загрузится первым, тот и сработает). | Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой. |
| `defer` | _Порядок документа_ (как расположены в документе).           | Выполняется после того, как документ загружен и обработан (ждёт), непосредственно перед `DOMContentLoaded`.                                                                                |