```dataview 
TABLE without id
file.outlinks AS "OUTGOING",
file.inlinks AS "BACKLINKS"
WHERE file.name = this.file.name
```
#reference/info
# Links
[[00. Javascript]]



# Description
[[03. Функции#try, catch, finally]]
[[03. Функции#This]]
[[03. Функции#Замыкания]]
[[03. Функции#Promise]]


## try, catch, finally
Конструкция для отлова ошибок.

Выглядит так:
```javascript
try{
	const x = 0
	x = 10
	throw new Error('Error')
}catch(err){
	console.log(err)
}finally{
	console.log("Скрипт, который выполнится в любом случае")
}
```

Если в секции `try` будет выведена ошибка, то продолжение блока `try` завершается и происходит переход в блок `catch`. Он существует для отлова и обработки ошибки.

Блок `finally` будет выполнен не зависимо от исхода как `try`, так и `catch`.

*Если в `catch` будет выведена ошибка, то код Javascript останавливается*

Так же есть оператор `throw` который генерирует ошибку. В последствии передастся в качестве аргумента в `catch`. 



## Замыкания
Замыкание - это комбинация функций и лексической области видимости, в которой эта функция была вызвана.

Пример:
```javascript
function nameFunction(){
	let a = 0
	return{
		()=>{
			return a++
		}
	}
}
```

В данном участке кода представлена функциональность замыкания.

По сути для того, что бы переменную не объявлять званого каждый раз или не засорять глобальную область видимости не нужными переменными, можно ей воспользоваться.

Переменная `a` остается в области видимости функции `nameFunction`, а манипуляции с ней производит безымянная функция, которая возвращается.

*Переменная остается в `scope`, так как javascript видит, что в дальнейшем, так как во вложенной функции обращаются к ней, возможно изменение значений.*

## Promise
```javascript
let promise = new Promise(function(resolve, reject){
	// функция-исполнитель (executor)
	resolve("done") /*или*/ reject(new Error("error"))
})
promise
	.then(()=>{})
	.catch(()=>{})
	.finally(()=>{})
```

Аргументы - колбэки функции:
- `resolve(value)` - eсли работа завершилась успешно,  с результатом `value`.
- `reject(error)` - если произошла ошибка, `error` - объект ошибки

Методы Promise:
- `.then((resolve)=>{})` - будет выполнена функция, если работа завершилась успешно. Так же можно передавать значение переданное в `resolve`.
- `.catch((reject)=>{})` - будет выполнена функция, если работа завершилась с ошибкой. Так же может передавать значение переданное в `reject`.
- `.finally(()=>{})`- будет выполнена функция, после сработки любого исхода.

У объекта promise, есть внутренние свойства:
- state (`"состояние"`) - вначале `"pending"`(`"ожидание"`), потом `"fulfilled"`(`"Выполненно успешно"`) при вызове ___resolve___ или `"rejected"`(`"Выполнено с ошибкой"`) при вызове ___reject___.
- result (`"результат"`) - вначале `"undefined"`, далее изменится на `"value"` при вызову ___resolve(value)___ или на `"error"` при вызову ___reject(error)___.
![[Pasted image 20241212083837.png]]

Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние Promise может быть изменено только один раз. Последующее вызов `resolve` или `reject` будет игнорирован.